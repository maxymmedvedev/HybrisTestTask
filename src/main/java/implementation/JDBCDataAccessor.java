package implementation;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

import interfaces.DBAcessor;
import interfaces.ProductStatus;
import lombok.Setter;

public class JDBCDataAccessor implements DBAcessor {
	@Setter private Connection conn;
	
	//insert connection dependency via constructor
	public JDBCDataAccessor(Connection dependency) {
		this.conn = dependency;
	}
	
	@Override
	public void createProduct(String name, int price, ProductStatus status) {
		String query = "INSERT INTO products "
				+ "(name, price, status) VALUES(?,?,?)";
		
		try(PreparedStatement insertProductStmt = conn.prepareStatement(query))
		{
			insertProductStmt.setString(1, name);
			insertProductStmt.setInt(2, price);
			insertProductStmt.setInt(3,status.getIndex());
			
			insertProductStmt.executeUpdate();
			System.out.println("Product created successfully");
		} catch (SQLException e) 
		{
			System.out.print("Something went wrong while inserting data: ");
			if(e.getMessage().startsWith("Duplicate entry")) 
			{
				System.out.println("Product with given name already exists");
			}else 
			{
				System.out.println(e.getMessage());
			}
			System.out.println("Product creation aborted");
		}

	}

	@Override
	public void createOrder(int... product_ids) {
		//since we don't specify any order details, all data are generated by the database
		String createOrder = "INSERT INTO orders () VALUES ()";
		String createOrderEntry = "INSERT INTO order_items (product_id, order_id)"
				+ "VALUES(?,?)";
		try(PreparedStatement createOrderStmt = conn.prepareStatement(createOrder, Statement.RETURN_GENERATED_KEYS);
		    PreparedStatement createOrderEntryStmt = conn.prepareStatement(createOrderEntry))
		{
			conn.setAutoCommit(false);
			createOrderStmt.executeUpdate();
			
			ResultSet keyRS = createOrderStmt.getGeneratedKeys();
			keyRS.next();
			int generatedOrderId = keyRS.getInt(1);
			
			int entryCount = 0;
			for(int x: product_ids) {
				createOrderEntryStmt.setInt(1, x);
				createOrderEntryStmt.setInt(2, generatedOrderId);
				createOrderEntryStmt.executeUpdate();
				entryCount++;
			}
			
			conn.commit();
			System.out.println("Order created. Order id is: " + generatedOrderId + ". "
							  + entryCount + " entries added");
		} catch (SQLException e) 
		{//the following code is boilerplate for handling exceptions and rolling back failed transactions 
			try {
				System.out.println("Something went wrong. Problem was: " + e.getMessage());
				System.out.print("Rolling back transaction...");
				conn.rollback();
				System.out.println("Done");
			} catch (SQLException e1) 
			{
				System.out.println("Failed. Exception occured: " + e.toString());
			}
		}finally 
		{
			try {
				conn.setAutoCommit(true);
			} catch (SQLException e) {
				System.out.println("WARNING: failed to reset connection's commit mode. Application reset is recommended"
								 + "\nProblem is: " + e.getMessage());
			}
		}

	}

	@Override
	//for pairs: key - product_id, value - quantity
	public void updateOrderQuantities(int order_id, Map<Integer, Integer> pairs) {
		String updateQuantity = "UPDATE order_items "
									 + "SET quantity=? "
									 + "WHERE (product_id = ?) "
									 + "AND (order_id = ?)";
		try(PreparedStatement updateQuantityStmt = conn.prepareStatement(updateQuantity))
		{	
			conn.setAutoCommit(false);
			int rowsUpdated = 0;
			
			Iterator<Map.Entry<Integer, Integer>> it = pairs.entrySet().iterator();
			Map.Entry<Integer, Integer> pair;
			while(it.hasNext()) {
				pair = it.next();
				
				updateQuantityStmt.setInt(1, pair.getValue());
				updateQuantityStmt.setInt(2, pair.getKey());
				updateQuantityStmt.setInt(3, order_id);
				
				rowsUpdated += updateQuantityStmt.executeUpdate();
			}
			
			conn.commit();
			if(rowsUpdated > 0) {System.out.println("Quantities for " + rowsUpdated + " entries updated successfully");
			} else {
				System.out.println("No product with such id are present in specifed order"); 
			}
		} catch (SQLException e) 
		{// boilerplate for handling exceptions and rolling back failed transactions 
			try {
				System.out.println("Something went wrong. Problem was: " + e.getMessage());
				System.out.print("Rolling back transaction...");
				conn.rollback();
				System.out.println("Done");
			} catch (SQLException e1) 
			{
				System.out.println("Failed. Exception occured: " + e.toString());
			}
		}finally 
		{
			try {
				conn.setAutoCommit(true);
			} catch (SQLException e) {
				System.out.println("WARNING: failed to reset connection's commit mode. Application reset is recommended"
								 + "\nProblem was: " + e.getMessage());
			}
		}

	}

	@Override
	public void removeProductById(int id, String password) {
		//changing user
		ConnectionManager.setUser("delete_user", password);
		//setting new connection
		this.conn = ConnectionManager.getConnection();
		
		String deleteProductQuery = "DELETE FROM products "
								  + "WHERE (id = ?)";
		
		String removeRelatedEntries = "DELETE FROM order_items "
				  + "WHERE (product_id = ?)";
		
		try(PreparedStatement deleteProductStmt = conn.prepareStatement(deleteProductQuery);
			PreparedStatement removeRelatedEntriesStmt = conn.prepareStatement(removeRelatedEntries)){
			
			conn.setAutoCommit(false);
			
			removeRelatedEntriesStmt.setInt(1, id);
			int remRelEntr = removeRelatedEntriesStmt.executeUpdate();
			System.out.println(remRelEntr + " related order entries removed");
			
			deleteProductStmt.setInt(1, id);
			int deletedProducts = deleteProductStmt.executeUpdate();
			
			if(deletedProducts > 0) {
				System.out.println("Product removed successfully");
			} else {
				System.out.println("No products with such id is present");
			};
		} catch (SQLException e) 
		{//handling exceptions and rolling back failed transactions 
			try {
				System.out.println("Something went wrong. Problem was: " + e.getMessage());
				System.out.print("Rolling back transaction...");
				conn.rollback();
				System.out.println("Done");
			} catch (SQLException e1) 
			{
				System.out.println("Failed. Exception occured: " + e.toString());
			}
		}finally 
		{
			try {
				conn.setAutoCommit(true);
			} catch (SQLException e) {
				System.out.println("WARNING: failed to reset connection's commit mode. Application reset is recommended"
								 + "\nProblem was: " + e.getMessage());
			}
		}
		//reseting user to default
		ConnectionManager.setUser();
		this.conn = ConnectionManager.getConnection();

	}

	@Override
	public void removeAllProducts(String password) {
		ConnectionManager.setUser("delete_user", password);
		this.conn = ConnectionManager.getConnection();
		
		String deleteAllProducts = "DELETE FROM products";
		String clearOrderEntries = "DELETE FROM order_items";
		
		try(PreparedStatement deleteAllProductsStmt = conn.prepareStatement(deleteAllProducts);
			PreparedStatement clearOrderEntriesStmt = conn.prepareStatement(clearOrderEntries)) 
		{
			int orderEntriesDeleted =  clearOrderEntriesStmt.executeUpdate();
			System.out.println(orderEntriesDeleted + " order entries deleted");
			
			int productsDeleted = deleteAllProductsStmt.executeUpdate();
			System.out.println(productsDeleted + " products deleted successfully");
		}catch (SQLException e) 
		{//handling exceptions and rolling back failed transactions 
			try {
				System.out.println("Something went wrong. Problem was: " + e.getMessage());
				System.out.print("Rolling back transaction...");
				conn.rollback();
				System.out.println("Done");
			} catch (SQLException e1) 
			{
				System.out.println("Failed. Exception occured: " + e.toString());
			}
		}finally 
		{
			try {
				conn.setAutoCommit(true);
			} catch (SQLException e) {
				System.out.println("WARNING: failed to reset connection's commit mode. Application reset is recommended"
								 + "\nProblem was: " + e.getMessage());
			}
		}
		//reset user to default
		ConnectionManager.setUser();
		this.conn = ConnectionManager.getConnection();
	}
	
	public ArrayList<String[]> getProductsView(){
			String getProducts = "SELECT id, name, price, status "
							   + "FROM products";
			return executeSelect(getProducts);
		}
		
		@Override
	public ArrayList<String[]> getOrderedProductsView(){
		String query = "SELECT  name, SUM(quantity) "
				+ "FROM products INNER JOIN order_items "
				+ "    ON products.id = order_items.product_id "
				+ "    GROUP BY name "
				+ "    ORDER BY SUM(quantity) DESC";
		return executeSelect(query);
	}
		
		@Override
	public ArrayList<String[]> getOrdersView(){
		String query = "SELECT  order_items.order_id, "
					 + "		(order_items.quantity * products.price) AS Products_total_price, "
					 + "		products.name, "
					 + "		order_items.product_id, "
					 + "		order_items.quantity, "
					 + "        orders.created_at "
					 + "FROM order_items "
					 + "INNER JOIN products ON order_items.product_id = products.id "
					 + "INNER JOIN orders ON orders.id = order_items.order_id "
					 + "ORDER BY order_id";
			
		return executeSelect(query);
	}

		
	private ArrayList<String[]> executeSelect(String query){
		
		ArrayList<String[]> res = new ArrayList<>();
		String[] row;
		
		try(PreparedStatement selectStmt = conn.prepareStatement(query))
		{
			ResultSet rs = selectStmt.executeQuery();
			ResultSetMetaData meta =rs.getMetaData();
				
			int columnCount = meta.getColumnCount();
				
			row = new String[columnCount];
			for(int i = 0; i < columnCount; i++) {
				row[i] = meta.getColumnName(i+1);
			}
			res.add(row);
			
			while(rs.next()) {
				row = new String[columnCount];
				for(int i = 0; i < columnCount; i++) {
					row[i] = rs.getString(i+1);
				}
				res.add(row);
			}
				
				
				
		} catch (SQLException e) {
			System.out.print("Something went wrong: " + e.getMessage());
		}	
				
		return res;
	}
	
}
